C++11引入右值引用可以减少拷贝构造的次数，多用移动构造。
由于拷贝构造在堆中先分配新的空间，再把原空间释放掉，会导致效率较低
而移动拷贝前后指向同一个堆空间，效率较高
在调用函数赋值时，如：
```cpp
bit::string ret = bit::to_string(1234);
```
若为拷贝构造与拷贝赋值，则效率较低
可使用移动构造与移动赋值：
```cpp
string(string&& s)
:_str(nullptr)
,_size(0)
,_capacity(0)
{
	cout << "string(string&& s) -- 移动构造" << endl;
	this->swap(s);
}

string& operator=(string&& s)
{
	cout << string"string& operator=(string&& s) -- 移动赋值" << endl;
	this->swap(s);
}
```
不需要额外分配空间，直接指向原数据的堆空间。
___
**`支持深拷贝的类，提供移动构造和移动赋值，这时这些类的对象进行传值返回或者是参数为右值时，则可以用移动构造和移动赋值，转移资源，避免深拷贝，提高效率。`**
___
**`右值引用的对象，再作为实参传递时，属性会退化为左值，只能匹配左值引用。使用完美转发，可以保持他的右值属性`**
___